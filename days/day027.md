## Track001 -  github

 
# ■ Github   
### 12. 깃허브 협업 
---
1. html + css + js/jquery      [개인]
2. spring + mybatis + jstl     
3. node + react
4. spring boot + thymeleaf + jpa + mybatis + react  
5. flutter + spring boot + jpa + mybatis + react


# JAVA
## . 다형성
- 많은 형상을 띄는 성품
- 여러타입의 객체(자식객체)를 하나의 타입(부모)으로 관리

1. 부모는 자식을 담을 수 있다. (업캐스팅)
--------------------------------
Animal [name, age / 먹기, 자기, 배변]

Cat    [card / 꾹꾹]
--------------------------------
Animal ani = new Cat();       부모 = 자식    고양이는 동물이다
1-1) Animal ani {name, age / 먹기, 자기, 배변}
1-2) Cat() → Animal() Object()
    {card / 꾹꾹} + {name, age / 먹기, 자기 , 배변}
 
2. 자식은 부모를 담을 수 있다. (다운캐스팅)
Cat cat =new Animal(); 자식 = 부모   동물은 고양이다

2-1) Cat cat 
{card / 꾹꾹} + {name, age / 먹기, 자기 , 배변}
2-2) new Animal() 
             {name,age / 먹기,자기,배변} 
 2-3 만족못시키는 범위 생김
    {card / 꾹꾹}
 > 2-4 해결방안
 부모타입에서 자식생성자를 호출한적이 있으면 사용가능.
 Animal ani = new Cat();      3000번지    {card / 꾹꾹} + {name, age / 먹기, 자기 , 배변}
        자식생성자를 호출해서 자식의 범위를 쓸 수 있게 만들었으므로
 Cat cat = (cat)ani
        부모객체에서 자식타입으로 [타입캐스팅]이 필요함
        cat(3000번지) = 3000번지 [{card / 꾹꾹} + {name, age/ 먹기,자기,배변}]


● 9. abstract
1. 추상화
- 실체화된 객체들 간에 공통되는 특성을 추출
- 미완성적인 개념 (new 사용못함)
- 공통된 필드와 메서드의 이름을 통일할 목적

2. 추상클래스
abstrack class Animal{
    String name; // 인스턴스변수 - this - 각각  
    abstrack void sound(); // abstrack method() - {} 구현부가 없음
}
class Cat extends Animal{@override void sound(){야옹}}
class Dog extends Animal{@override void sound(){멍멍}}

● 10. interface
1. interface
- 개발코드변경없이 객체룰 바꿔낄 수 있도록 하는 역할

2. abstract (Is A: 고양이는 동물이다) vs interface (can do this)
- 추상화 정도가 interface가 더 높다.
1) abstract - 인스턴수변수, 일반메서드, 추상메서드(abstract) 가질 수 있음
2) interface - 상수(public static final) + 추상메서드(public abstrack)만 가짐
3) 프로젝트 진행시 interface 사용 
- 다른 구성원들이 각각의 부분을 완성할때까지 기다리지않고 규약만 정해두면 본인 부분만 작성
4) interface 형식
------------------------------------------------------
interface 인터페이스명{
    상수;  // public static final 
    추상메서드; // public abstract {} x this x 
}
------------------------------------------------------
class interSon implements 인터페이스명{}
class interSo2 extends 클래스명 implements 인터페이스명1, 인터페이스명2{}



# ■ WEB BASIC


# ■ JAVA
# ■ JAVA 복습문제
Q1. 다음의 상속도를 그리시오.
Q2. 상속도에서  각각의 클래스에서 사용가능한 멤버변수/멤버함수를  적으시오.

abstract class Animal{    
	String name; 
	abstract void eat();   
	abstract void sleep(); 
	abstract void poo();  
}
class Cat  extends Animal{  // 구현클래스 - 고양이는 동물이다
	@Override void eat()   {  System.out.println(super.name + "고양이 냠냠!");  }
	@Override void sleep() {  System.out.println(super.name + "고양이 수면!");  }
	@Override void poo()   {  System.out.println(super.name + "고양이 시원");  }
}
class Dog  extends Animal{  // 구현클래스 - 강아지는 동물이다
	@Override void eat()   {  System.out.println(super.name + "강아지 냠냠!");  }
	@Override void sleep() {  System.out.println(super.name + "강아지 수면!");  }
	@Override void poo()   {  System.out.println(super.name + "강아지 시원");  }
}
public class Abstract001 {
	public static void main(String[] args) {
		//1. abstract  class : 일반클래스 + 설계
		Animal ani = new Animal();   Q3. 이코드에서 오류나는 이유는? 
	 
		Animal ani = null;
		ani = new Cat();   //Q4. 다형성에서 다음을 뭐라하는가?   업캐스팅/다운캐스팅? , 타입캐스팅 필요여부
		ani.name = "sally";   ani.eat();
 
		
		//2. 사용목적
		Animal [] arr = {new Cat() , new Cat() , new Dog() , new Dog() , };
		int cnt=0;
		//Q5.  다음이 출력되게 코드를 작성하시오.
		/*ani1고양이 냠냠!
		  ani2고양이 냠냠!
		  ani3강아지 냠냠!
		 ani4강아지 냠냠!   */
	}
}


>>>>>>>>>>>>>>>>> Answer
```
/* Q1,Q2
	    Object  
      	↑
	     Animal {name / eat(), sleep(), poo() }
	     ↑   ↑ 
	    Cat  Dog  { @eat(), @sleep(), @poo() }
*/

abstract class Animal{   //일반클래스 + 설계
	String name; 
	abstract void eat();  // 추상메서드가 있으면 반드시 추상클래스로 만들어줘야함.
	abstract void sleep();// 구현부가 없음 {}
	abstract void poo();  // 추상화, 일반화, 설계: 공통의 속성, 구체적인 내용이 없음
}
class Cat  extends Animal{  // 구현클래스 - 고양이는 동물이다
	@Override void eat()   {  System.out.println(super.name + "고양이 냠냠!");  }
	@Override void sleep() {  System.out.println(super.name + "고양이 수면!");  }
	@Override void poo()   {  System.out.println(super.name + "고양이 시원");  }
}
class Dog  extends Animal{  // 구현클래스 - 강아지는 동물이다
	@Override void eat()   {  System.out.println(super.name + "강아지 냠냠!");  }
	@Override void sleep() {  System.out.println(super.name + "강아지 수면!");  }
	@Override void poo()   {  System.out.println(super.name + "강아지 시원");  }
}
public class Abstract001 {
	public static void main(String[] args) {
		//1. abstract  class : 일반클래스 + 설계
		// Animal ani = new Animal();   Q3 new 메모리빌리고,객체생성/ Animal()초기화, {}구현부없음
		// 
		Animal ani = null;
		ani = new Cat();   // Q4. 부모 = 자식 , 업캐스팅, 타입캐스팅 필요없음
		ani.name = "sally";   ani.eat();

		ani = new Dog();   // 부모 = 자식 , 업캐스팅, 타입캐스팅 필요없음
		ani.name = "alpha";   ani.eat();
		
		//2. 사용목적
		Animal [] arr = {new Cat() , new Cat() , new Dog() , new Dog() , };
		int cnt=0;
		//Q5
      for(Animal a :  arr) {  a.name = "ani" + ++cnt;  a.eat();  }
	}
} 
```

